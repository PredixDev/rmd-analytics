{"name":"Rmd-analytics","tagline":"micro","body":"<a href=\"../../../../pages/adoption/rmd-analytics/javadocs/index.html\" target=\"_blank\" >\r\n\t<img height=\"50px\" width=\"100px\" src=\"images/javadoc.png\" alt=\"view javadoc\"></a>\r\n&nbsp;\r\n<a href=\"../../../../pages/adoption/rmd-analytics\" target=\"_blank\">\r\n\t<img height=\"50px\" width=\"100px\" src=\"images/pages.jpg\" alt=\"view github pages\">\r\n</a>\r\nAnalytics for Predix RMD Reference App\r\n=====================\r\nThe right Analytic Interface can provide Algorithm portability and the flexibility to handle Data from any Datasource while empowering the developer to create analytics in any Language on any execution platform.  This value proposition is achieved by leveraging the techniques here with the power of the Predix platform.\r\n\r\n<img src=https://github.com/PredixDev/predix-rmd-ref-app/raw/master/images/RefApp-AnalyticsFlow.png/>\r\n\r\nThe Predix Orchestration Engine invokes 2 types of Analytic microservices.  \r\n\r\nType 1 is a simple python, matlab or other supported script and data which is submitted to the Predix Analytic Catalog where Predix auto-wraps and deploys the script to the cloud.  \r\n\r\nThis project is a template for the 2nd type; a custom Analytic where you need control of the microservice and the contents particularly when resolving data at runtime using ClientId tokens to secure services such as PredixAsset and PredixTimeseries.\r\n\r\nThe Reference App helps you define a commmon API and lifecycle allowing the analytic to run in any language, on any operating system, against near-data, distributed data or cloud-based data sources.  The design is portable and can be taken to the edge on Predix Machine.  \r\n\r\n##Orchestrated Analytics\r\n<img src=\"images/simple_orchestration.png\">\r\n\r\nThe Predix orchestration engine invokes each analytic in a workflow.  The workflow can be complex with forks and joins.\r\n\r\n##Individual Analytic Lifecycle\r\nThe Analytic resolves the data, performs the calculation and then stores or caches the data.  Data resolution and storage is managed by the [Federated Data Handler](https://github.com/PredixDev/fdh-router-service) allowing any datastore to be accessed.\r\n\r\n<img src=\"images/analytic-lifecycle.png\">\r\n\r\nThe [Run Analytic API](https://github.com/PredixDev/ext-interface/blob/master/ext-interface/src/main/resources/META-INF/schemas/pm/entity/runanalytic/runanalytic.xsd) (best viewed in Eclipse STS) creates a Rest Based api that can be invoked in the cloud, for streaming analytics, against near-data analytics (map-reduce, etc), or also at the edge (on Machines outside the cloud).  \r\n\r\n> Why XSDs?  We work with other XSD Industrial Internet based libraries.  XML is not required.  We use REST and we prefer JSON at runtime.  We like the type-safety validation and generation tools of XSD.  We like to support other languages with the same API.  We like polymorphism.  We like enumerations.  We like contracts. We like the embedded docs.     \r\n\r\nRunAnalytic contains a simple list of InputPort and a list of OutputPort.  The input port \"template\" below says we want the name to be ALARM_HI and the FieldSelection is a Real number and correlation resultId should be marked with ALARM_HI.\r\n```json\r\n{\r\n    \"portIdentifier\": {\r\n        \"complexType\": \"PortIdentifier\",\r\n        \"id\": \"ALARM_HI\",\r\n        \"name\": \"ALARM_HI\"\r\n    },\r\n    \"fieldSelection\": {\r\n        \"expectedDataType\": \"DMReal\",\r\n        \"resultId\": \"ALARM_HI\"\r\n    }\r\n}\r\n```\r\nHere is the same structure in a picture. (defined by an xsd)\r\n<img src=\"images/port_template.png\">\r\n\r\nDefining other ports is easy because it's just a name and an expectedDataType.  \r\n\r\n##Data\r\nWe can define Real, Int, Boolean, String, Timeseries or any data structures that are expected for our ports. These are the most common, but any Data Type can be defined because the API support Animal, Cat, Dog polymorphic semantics.\r\n\r\nThis is a notional image just to give a quick overview of the common types of data.  The actual structures don't have a commonDataTypes wrapper.\r\n\r\n<img src=\"images/common-data-types.png\">\r\n\r\n##Analytic Template\r\nMany Analytics are reusable, so the Template definition of Port Name, Expected DataType and Expected EngineeringUnit (celcius, fahrenheit, etc) define what the analytic wants.  The data resolved by the Analytic could be from a variety of data sources (customer specific datasources, files, hadoop, rdbms, cache, Asset, Timeseries, etc).  \r\n\r\n>This technique of defining the Analytic Template, configuring the DataBinding and Filter where clauses and doing late data-binding at runtime allow the Analytics, and the tooling to support this, to apply to any execution runtime against any datasource.  \r\n\r\n##DataBinding to the FieldSelection\r\nWhen we assign a Field and Filter to the Port we call this Data Binding.  It simply means we are defining which Attribute from which Datasource and which Where clause to use at runtime.  Each Port for the analytic usually has different where clause semantics relative to the problem at hand.\r\n\r\nThe FieldIdentifer has an id, name, and source.  The id is a Rest principle based string indicating where to find the Real, Int, String, Bool, or Timeseries attribute within a datasource.\r\n\r\n<img src=\"images/field_identifier.png\">\r\n\r\nThis Input port says to get the ALARM_HI from PREDIX_ASSET by looking up an Asset and looking for \"crank-frame-dischargepressure\" in the Map\\<String,AssetTag\\> for the outputMaximum attribute.  \r\n\r\n```json\r\n{\r\n\t\t\t\"portIdentifier\": \r\n\t\t\t{\r\n\t\t\t\t\"complexType\": \"PortIdentifier\",\r\n\t\t\t\t\"id\": \"ALARM_HI\",\r\n\t\t\t},\r\n\t\t\t\"fieldSelection\": \r\n\t\t\t{\r\n\t\t\t\t\"fieldIdentifier\": \r\n\t\t\t\t{\r\n\t\t\t\t\t\"complexType\": \"FieldIdentifier\",\r\n\t\t\t\t\t\"id\": \"/asset/assetTag/crank-frame-dischargepressure/outputMaximum\",\r\n\t\t\t\t\t\"source\": \"PREDIX_ASSET\"\r\n\t\t\t\t},\r\n\r\n\t\t\t\t\"expectedDataType\": \"DMReal\",\r\n\t\t\t\t\"resultId\": \"ALARM_HI\"\r\n\t\t\t},\r\n```\r\n\r\nIn the full Port definition depicted below notice the FieldSelection defines the data, the Filter allows for a where clause, the Engineering Units are defined, the portType handles some edge cases and even optional Data can be passed in  instead of resolved later.\r\n\r\n<img src=\"images/port.png\">\r\n\r\nThe Selection Filter is a where clause which also has Animal, Cat, Dog polymorphic semantics.  We can define any Selection Filter we want.  We have defined 2 Filters which will take you a long way in Predix.  A TimeFilter which mirrors the Predix Timeseries API and simply 'extends' Filter.  And a FieldFilter which allows for basic AND/OR semantics similar to a where clause.    Filters can return multiple Models (like rows in a database) and thus Analytic actions can be performed on the set of data returned.\r\n\r\n<img src=\"images/predix-time-selection-filter.png\">\r\n<img src=\"images/field-selection-filter.png\">\r\n\r\n##Traversing the Model\r\n\r\nField definitions represent data and are influenced by Predix Asset JSON models.  It turns out that all json structures when unmarshaled to objects are primitives, objects, maps or lists.  Say, we search for an Asset trying to retrieve the OutputMaximum attribute.  The items in-between are a traversal of the Asset object-graph json.  Predix Asset supports any 'model' json structure.  In this case the model is an Asset.  But it could be /plane/wingspan or /address/city.  \r\n\r\nOur implementation uses standard json libraries to find the attribute within the model.  We use Jackson since it handles polymorphic objects better than Gson.  We also do not have to register mappers for each object type we create.  This should increase productivity since you can concentrate on Modeling and not the plumbing of marshaling/unmarshaling Json.\r\n\r\n<img src=\"images/model_attribute.png\">\r\n\r\n##Summary\r\nTo summarize, starting with an AnalyticTemplate defining a Port name, datatype and engineering unit, we can bind a Field and Data Source to it and define a Filter where clause.  When a RunAnalyticRequest is made the Analytic Resolves the data, computes a result and Stores/Caches the result using an OutputPort definition and 'Data', which also has Polymormic semantics.  [Federated Data Handler](https://github.com/PredixDev/fdh-router-service) manages the Data Resolution and Storage/Cache requests.  Control is returned to the Orchestration Engine and the next Analytic is invoked.\r\n\r\n<img src=\"images/port.png\">\r\n\r\nHere are 3 input ports defined for the Alarm Threshold Analytic used by the Reference App.\r\n```json\r\n\"inputPort\": \r\n\t[\r\n\t\t{\r\n\t\t\t\"portIdentifier\": \r\n\t\t\t{\r\n\t\t\t\t\"complexType\": \"PortIdentifier\",\r\n\t\t\t\t\"id\": \"ALARM_HI\",\r\n\t\t\t\t\"name\": \"ALARM_HI\"\r\n\t\t\t},\r\n\r\n\t\t\t\"fieldSelection\": \r\n\t\t\t{\r\n\t\t\t\t\"fieldIdentifier\": \r\n\t\t\t\t{\r\n\t\t\t\t\t\"complexType\": \"FieldIdentifier\",\r\n\t\t\t\t\t\"id\": \"/asset/assetTag/crank-frame-dischargepressure/outputMaximum\",\r\n\t\t\t\t\t\"name\": \"/asset/assetTag/crank-frame-dischargepressure/outputMaximum\",\r\n\t\t\t\t\t\"source\": \"PREDIX_ASSET\"\r\n\t\t\t\t},\r\n\r\n\t\t\t\t\"expectedDataType\": \"DMReal\",\r\n\t\t\t\t\"resultId\": \"ALARM_HI\"\r\n\t\t\t},\r\n\r\n\t\t\t\"filter\": \r\n\t\t\t{\r\n\t\t\t\t\"complexType\": \"FieldFilter\",\r\n\t\t\t\t\"fieldIdentifierValue\": \r\n\t\t\t\t[\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t\"fieldIdentifier\": \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"complexType\": \"FieldIdentifier\",\r\n\t\t\t\t\t\t\t\"id\": \"/asset/assetId\",\r\n\t\t\t\t\t\t\t\"source\": \"PREDIX_ASSET\"\r\n\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t\"value\": \"/asset/compressor-2015\"\r\n\t\t\t\t\t}\r\n\t\t\t\t]\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t{\r\n\t\t\t\"portIdentifier\": \r\n\t\t\t{\r\n\t\t\t\t\"complexType\": \"PortIdentifier\",\r\n\t\t\t\t\"id\": \"ALARM_LO\",\r\n\t\t\t\t\"name\": \"ALARM_LO\"\r\n\t\t\t},\r\n\r\n\t\t\t\"fieldSelection\": \r\n\t\t\t{\r\n\t\t\t\t\"fieldIdentifier\": \r\n\t\t\t\t{\r\n\t\t\t\t\t\"complexType\": \"FieldIdentifier\",\r\n\t\t\t\t\t\"id\": \"/asset/assetTag/crank-frame-dischargepressure/outputMinimum\",\r\n\t\t\t\t\t\"name\": \"/asset/assetTag/crank-frame-dischargepressure/outputMinimum\",\r\n\t\t\t\t\t\"source\": \"PREDIX_ASSET\"\r\n\t\t\t\t},\r\n\r\n\t\t\t\t\"expectedDataType\": \"DMReal\",\r\n\t\t\t\t\"resultId\": \"ALARM_LO\"\r\n\t\t\t},\r\n\r\n\t\t\t\"filter\": \r\n\t\t\t{\r\n\t\t\t\t\"complexType\": \"FieldFilter\",\r\n\t\t\t\t\"fieldIdentifierValue\": \r\n\t\t\t\t[\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t\"fieldIdentifier\": \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"complexType\": \"FieldIdentifier\",\r\n\t\t\t\t\t\t\t\"id\": \"/asset/assetId\",\r\n\t\t\t\t\t\t\t\"source\": \"PREDIX_ASSET\"\r\n\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t\"value\": \"/asset/compressor-2015\"\r\n\t\t\t\t\t}\r\n\t\t\t\t]\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t{\r\n\t\t\t\"portIdentifier\": \r\n\t\t\t{\r\n\t\t\t\t\"complexType\": \"PortIdentifier\",\r\n\t\t\t\t\"id\": \"TS_DATA\",\r\n\t\t\t\t\"name\": \"TS_DATA\"\r\n\t\t\t},\r\n\r\n\t\t\t\"fieldSelection\": \r\n\t\t\t{\r\n\t\t\t\t\"fieldIdentifier\": \r\n\t\t\t\t{\r\n\t\t\t\t\t\"complexType\": \"FieldIdentifier\",\r\n\t\t\t\t\t\"id\": \"/asset/assetTag/crank-frame-dischargepressure\",\r\n\t\t\t\t\t\"name\": \"/asset/assetTag/crank-frame-dischargepressure\",\r\n\t\t\t\t\t\"source\": \"PREDIX_TIMESERIES\"\r\n\t\t\t\t},\r\n\r\n\t\t\t\t\"expectedDataType\": \"DMDataSeq\",\r\n\t\t\t\t\"resultId\": \"TS_DATA\"\r\n\t\t\t},\r\n\r\n\t\t\t\"filter\": \r\n\t\t\t{\r\n\t\t\t\t\"complexType\": \"FieldFilter\",\r\n\t\t\t\t\"fieldIdentifierValue\": \r\n\t\t\t\t[\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t\"fieldIdentifier\": \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"complexType\": \"FieldIdentifier\",\r\n\t\t\t\t\t\t\t\"id\": \"/asset/assetId\",\r\n\t\t\t\t\t\t\t\"source\": \"PREDIX_TIMESERIES\"\r\n\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t\"value\": \"/asset/compressor-2015\"\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t\"fieldIdentifier\": \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"complexType\": \"FieldIdentifier\",\r\n\t\t\t\t\t\t\t\"id\": \"startTime\"\r\n\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t\"value\": \"2015-08-01 11:00:00\"\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t\"fieldIdentifier\": \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"complexType\": \"FieldIdentifier\",\r\n\t\t\t\t\t\t\t\"id\": \"endTime\"\r\n\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t\"value\": \"2015-08-08 23:00:00\"\r\n\t\t\t\t\t}\r\n\t\t\t\t]\r\n\t\t\t}\r\n\t\t}\r\n\t],\r\n```\r\n(future integration)Predix provides a place to store the Orchestration BPMN file(s), Analytic Template(s), and Analytic DataBinding file(s).  See [Analytic Runtime](https://predix.ge.com/catalog/service.html?id=1174) \r\n\r\nYou can find a sample orchestration BPMN file, as well as a complete JSON request that can be submitted to Predix Analytics, in the OrchestrationFiles and src/test/resources directories of this project.\r\n\r\n\r\n\r\n##Tech Stack\r\n- Spring\r\n- SpringBoot\r\n- SpringTest\r\n- Maven\r\n\r\n##Microcomponents\r\n- [AssetBootstrap](https://github.com/predixdev/asset-bootstrap)\r\n- [TimeseriesBootstrap](https://github.com/predixdev/timeseries-bootstrap)\r\n- [PredixMicroserviceTemplates](https://github.com/predixdev/predix-microservice-templates)\r\n- [PredixRestClient](https://github.com/predixdev/predix-rest-client)\r\n\r\n### More Details\r\n* [More GE resources](http://github.com/predixdev/predix-rmd-ref-app/docs/resources.md)\r\n* [RMD Reference App](http://github.com/predixdev/predix-rmd-ref-app)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}